<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Modern Tic Tac Toe</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#6366f1',
                        xColor: '#ef4444',
                        oColor: '#3b82f6'
                    },
                    animation: {
                        'zoom-in': 'zoomIn 0.3s ease forwards',
                        'fade-in': 'fadeIn 0.5s ease forwards',
                        'wiggle': 'wiggle 1s ease infinite'
                    },
                    keyframes: {
                        zoomIn: {
                            '0%': { transform: 'scale(0.5)', opacity: '0' },
                            '100%': { transform: 'scale(1)', opacity: '1' }
                        },
                        fadeIn: {
                            '0%': { opacity: '0' },
                            '100%': { opacity: '1' }
                        },
                        wiggle: {
                            '0%, 100%': { transform: 'rotate(-3deg)' },
                            '50%': { transform: 'rotate(3deg)' }
                        }
                    }
                }
            }
        }
    </script>
    <style>
        .board-cell {
            transition: background-color 0.3s;
        }
        
        .board-cell:hover:not(.filled) {
            background-color: #f3f4f6;
        }
        
        .win-line {
            position: absolute;
            background-color: #10b981;
            z-index: 10;
        }
        
        @media (max-width: 640px) {
            .game-title {
                font-size: 1.5rem;
            }
            .stats-box {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen flex flex-col items-center justify-center p-4 font-sans">
    <div class="w-full max-w-md mx-auto">
        <!-- Header -->
        <header class="text-center mb-8">
            <h1 class="game-title text-3xl md:text-4xl font-bold text-gray-800 mb-2">
                <span class="text-primary">Tic</span> Tac <span class="text-primary">Toe</span>
            </h1>
            <p class="text-gray-600">Classic game, modern design</p>
        </header>
        
        <!-- Game Stats -->
        <div class="flex stats-box justify-between items-center mb-6 p-4 bg-white rounded-xl shadow-md">
            <div class="player-info bg-gray-100 px-4 py-3 rounded-lg flex items-center gap-3">
                <div class="relative">
                    <div class="h-3 w-3 rounded-full bg-primary absolute -top-1 -right-1 animate-ping"></div>
                    <div class="h-3 w-3 rounded-full bg-primary absolute -top-1 -right-1"></div>
                    <i class="fas fa-user text-primary text-xl"></i>
                </div>
                <div>
                    <p class="text-xs text-gray-500">Player (X)</p>
                    <p id="playerScore" class="font-bold text-xl">0</p>
                </div>
            </div>
            
            <div class="turn-indicator p-2">
                <div id="currentTurn" class="px-4 py-2 bg-primary text-white rounded-full font-medium flex items-center gap-2">
                    <span>X's Turn</span>
                    <i class="fas fa-sync-alt animate-spin"></i>
                </div>
            </div>
            
            <div class="player-info bg-gray-100 px-4 py-3 rounded-lg flex items-center gap-3">
                <i class="fas fa-robot text-blue-500 text-xl"></i>
                <div>
                    <p class="text-xs text-gray-500">Computer (O)</p>
                    <p id="computerScore" class="font-bold text-xl">0</p>
                </div>
            </div>
        </div>
        
        <!-- Game Board -->
        <div class="relative">
            <div id="gameBoard" class="grid grid-cols-3 gap-3 bg-gray-800 p-4 rounded-2xl shadow-xl">
                <!-- Cells will be generated by JS -->
            </div>
            
            <!-- Win Line Overlay -->
            <div id="winLine" class="win-line"></div>
        </div>
        
        <!-- Controls -->
        <div class="mt-8 flex justify-center">
            <button id="restartBtn" class="flex items-center gap-2 bg-primary hover:bg-indigo-600 text-white px-6 py-3 rounded-full font-medium transition-all shadow-md hover:shadow-lg transform hover:scale-105 active:scale-95">
                <i class="fas fa-redo"></i>
                Restart Game
            </button>
        </div>
        
        <!-- Result Modal -->
        <div id="resultModal" class="fixed inset-0 flex items-center justify-center z-50 hidden">
            <div class="absolute inset-0 bg-black bg-opacity-50 backdrop-blur-sm"></div>
            <div class="relative bg-white rounded-2xl p-8 max-w-md w-full mx-4 shadow-2xl transform scale-95 opacity-0 transition-all duration-300">
                <h2 id="resultTitle" class="text-2xl font-bold mb-4 text-center"></h2>
                <p id="resultSubtitle" class="text-gray-600 mb-6 text-center"></p>
                <div class="flex justify-center">
                    <button id="playAgainBtn" class="bg-primary hover:bg-indigo-600 text-white px-6 py-2 rounded-lg font-medium transition-all">
                        Play Again
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game state
            const gameState = {
                board: Array(9).fill(''),
                currentPlayer: 'X',
                scores: { playerX: 0, computerO: 0 },
                gameActive: true,
                winCombo: null,
                vsComputer: true
            };

            // DOM Elements
            const gameBoard = document.getElementById('gameBoard');
            const currentTurnElement = document.getElementById('currentTurn');
            const playerScoreElement = document.getElementById('playerScore');
            const computerScoreElement = document.getElementById('computerScore');
            const restartBtn = document.getElementById('restartBtn');
            const resultModal = document.getElementById('resultModal');
            const resultTitle = document.getElementById('resultTitle');
            const resultSubtitle = document.getElementById('resultSubtitle');
            const playAgainBtn = document.getElementById('playAgainBtn');
            const winLine = document.getElementById('winLine');

            // Initialize the board
            function initBoard() {
                gameBoard.innerHTML = '';
                winLine.style.display = 'none';
                winLine.style.width = '0';
                winLine.style.height = '0';
                
                for (let i = 0; i < 9; i++) {
                    const cell = document.createElement('div');
                    cell.classList.add(
                        'board-cell', 
                        'aspect-square', 
                        'flex', 
                        'items-center', 
                        'justify-center', 
                        'text-5xl', 
                        'font-bold', 
                        'bg-white', 
                        'rounded-xl', 
                        'shadow', 
                        'cursor-pointer',
                        'transition-transform',
                        'duration-200'
                    );
                    
                    // Hover effect
                    cell.addEventListener('mouseenter', () => {
                        if (!cell.classList.contains('filled') && gameState.gameActive) {
                            cell.classList.add('scale-105');
                        }
                    });
                    
                    cell.addEventListener('mouseleave', () => {
                        cell.classList.remove('scale-105');
                    });
                    
                    // Handle cell click
                    cell.addEventListener('click', () => makeMove(i));
                    
                    gameBoard.appendChild(cell);
                }
            }

            // Make a move
            function makeMove(index) {
                if (!gameState.gameActive || gameState.board[index] !== '') return;
                
                // Update game state
                gameState.board[index] = gameState.currentPlayer;
                updateBoard();
                
                // Check for win/draw
                const winResult = checkWin();
                if (winResult) {
                    handleWin(winResult);
                } else if (checkDraw()) {
                    handleDraw();
                } else {
                    // Switch player
                    gameState.currentPlayer = gameState.currentPlayer === 'X' ? 'O' : 'X';
                    updateTurnIndicator();
                    
                    // Computer's turn if playing vs computer
                    if (gameState.vsComputer && gameState.currentPlayer === 'O' && gameState.gameActive) {
                        setTimeout(makeComputerMove, 600);
                    }
                }
            }

            // Computer makes a move (simple AI)
            function makeComputerMove() {
                if (!gameState.gameActive) return;
                
                let moveMade = false;
                
                // Try to win if possible
                for (let i = 0; i < 9; i++) {
                    if (gameState.board[i] === '') {
                        gameState.board[i] = 'O';
                        if (checkWin('O')) {
                            moveMade = true;
                            break;
                        }
                        gameState.board[i] = '';
                    }
                }
                
                // Block opponent if they can win
                if (!moveMade) {
                    for (let i = 0; i < 9; i++) {
                        if (gameState.board[i] === '') {
                            gameState.board[i] = 'X';
                            if (checkWin('X')) {
                                gameState.board[i] = 'O';
                                moveMade = true;
                                break;
                            }
                            gameState.board[i] = '';
                        }
                    }
                }
                
                // Try to take center
                if (!moveMade && gameState.board[4] === '') {
                    gameState.board[4] = 'O';
                    moveMade = true;
                }
                
                // Try to take any corner
                const corners = [0, 2, 6, 8];
                if (!moveMade) {
                    for (const corner of corners) {
                        if (gameState.board[corner] === '') {
                            gameState.board[corner] = 'O';
                            moveMade = true;
                            break;
                        }
                    }
                }
                
                // Take any available space
                if (!moveMade) {
                    for (let i = 0; i < 9; i++) {
                        if (gameState.board[i] === '') {
                            gameState.board[i] = 'O';
                            moveMade = true;
                            break;
                        }
                    }
                }
                
                updateBoard();
                
                // Check if computer won after its move
                const winResult = checkWin();
                if (winResult) {
                    handleWin(winResult);
                } else if (checkDraw()) {
                    handleDraw();
                } else {
                    gameState.currentPlayer = 'X';
                    updateTurnIndicator();
                }
            }

            // Update board display
            function updateBoard() {
                const cells = document.querySelectorAll('.board-cell');
                gameState.board.forEach((cell, index) => {
                    cells[index].textContent = cell;
                    cells[index].classList.toggle('filled', cell !== '');
                    
                    if (cell === 'X') {
                        cells[index].classList.add('text-xColor');
                        cells[index].classList.remove('text-oColor');
                    } else if (cell === 'O') {
                        cells[index].classList.add('text-oColor');
                        cells[index].classList.remove('text-xColor');
                    }
                    
                    // Animation for latest move
                    if (cell !== '') {
                        cells[index].classList.add('animate-zoom-in');
                        setTimeout(() => {
                            cells[index].classList.remove('animate-zoom-in');
                        }, 300);
                    }
                });
            }

            // Update player turn indicator
            function updateTurnIndicator() {
                if (gameState.currentPlayer === 'X') {
                    currentTurnElement.innerHTML = `<span>X's Turn</span> <i class="fas fa-sync-alt animate-spin"></i>`;
                    currentTurnElement.classList.add('bg-primary');
                    currentTurnElement.classList.remove('bg-blue-500');
                } else {
                    currentTurnElement.innerHTML = `<span>O's Turn</span> <i class="fas fa-cog animate-spin"></i>`;
                    currentTurnElement.classList.add('bg-blue-500');
                    currentTurnElement.classList.remove('bg-primary');
                }
            }

            // Check win conditions
            function checkWin() {
                const winCombinations = [
                    [0, 1, 2], [3, 4, 5], [6, 7, 8], // rows
                    [0, 3, 6], [1, 4, 7], [2, 5, 8], // columns
                    [0, 4, 8], [2, 4, 6]             // diagonals
                ];
                
                for (const combo of winCombinations) {
                    const [a, b, c] = combo;
                    if (gameState.board[a] && 
                        gameState.board[a] === gameState.board[b] && 
                        gameState.board[a] === gameState.board[c]) {
                        return {
                            player: gameState.board[a],
                            combo: combo
                        };
                    }
                }
                
                return null;
            }

            // Check for draw
            function checkDraw() {
                return gameState.board.every(cell => cell !== '') && !checkWin();
            }

            // Handle win
            function handleWin(result) {
                gameState.gameActive = false;
                
                // Draw win line
                drawWinLine(result.combo);
                
                // Update score
                if (result.player === 'X') {
                    gameState.scores.playerX++;
                    playerScoreElement.textContent = gameState.scores.playerX;
                } else {
                    gameState.scores.computerO++;
                    computerScoreElement.textContent = gameState.scores.computerO;
                }
                
                // Show result modal
                resultTitle.textContent = result.player === 'X' ? 'Player X Wins!' : 'Player O Wins!';
                resultTitle.className = `text-2xl font-bold mb-4 text-center ${result.player === 'X' ? 'text-xColor' : 'text-oColor'}`;
                resultSubtitle.textContent = 'Congratulations!';
                
                showResultModal();
            }

            // Handle draw
            function handleDraw() {
                gameState.gameActive = false;
                
                // Show result modal
                resultTitle.textContent = 'Game Drawn!';
                resultTitle.className = 'text-2xl font-bold mb-4 text-center text-gray-700';
                resultSubtitle.textContent = 'No winner this time...';
                
                showResultModal();
            }

            // Draw the win line
            function drawWinLine(combo) {
                const cells = document.querySelectorAll('.board-cell');
                const firstCell = cells[combo[0]].getBoundingClientRect();
                const boardRect = gameBoard.getBoundingClientRect();
                
                // Determine line orientation
                if (combo.includes(0) && combo.includes(2)) {
                    // Horizontal top row
                    winLine.style.top = firstCell.top - boardRect.top + firstCell.height / 2 - 4 + 'px';
                    winLine.style.left = '20px';
                    winLine.style.width = boardRect.width - 40 + 'px';
                    winLine.style.height = '8px';
                } else if (combo.includes(3) && combo.includes(5)) {
                    // Horizontal middle row
                    const cellRect = cells[3].getBoundingClientRect();
                    winLine.style.top = cellRect.top - boardRect.top + cellRect.height / 2 - 4 + 'px';
                    winLine.style.left = '20px';
                    winLine.style.width = boardRect.width - 40 + 'px';
                    winLine.style.height = '8px';
                } else if (combo.includes(6) && combo.includes(8)) {
                    // Horizontal bottom row
                    const cellRect = cells[6].getBoundingClientRect();
                    winLine.style.top = cellRect.top - boardRect.top + cellRect.height / 2 - 4 + 'px';
                    winLine.style.left = '20px';
                    winLine.style.width = boardRect.width - 40 + 'px';
                    winLine.style.height = '8px';
                } else if (combo.includes(0) && combo.includes(6)) {
                    // Vertical first column
                    winLine.style.left = firstCell.left - boardRect.left + firstCell.width / 2 - 4 + 'px';
                    winLine.style.top = '20px';
                    winLine.style.height = boardRect.height - 40 + 'px';
                    winLine.style.width = '8px';
                } else if (combo.includes(1) && combo.includes(7)) {
                    // Vertical second column
                    const cellRect = cells[1].getBoundingClientRect();
                    winLine.style.left = cellRect.left - boardRect.left + cellRect.width / 2 - 4 + 'px';
                    winLine.style.top = '20px';
                    winLine.style.height = boardRect.height - 40 + 'px';
                    winLine.style.width = '8px';
                } else if (combo.includes(2) && combo.includes(8)) {
                    // Vertical third column
                    const cellRect = cells[2].getBoundingClientRect();
                    winLine.style.left = cellRect.left - boardRect.left + cellRect.width / 2 - 4 + 'px';
                    winLine.style.top = '20px';
                    winLine.style.height = boardRect.height - 40 + 'px';
                    winLine.style.width = '8px';
                } else if (combo.includes(0) && combo.includes(8)) {
                    // Diagonal top-left to bottom-right
                    winLine.style.width = Math.sqrt(Math.pow(boardRect.width, 2) + Math.pow(boardRect.height, 2)) + 'px';
                    winLine.style.height = '8px';
                    winLine.style.transformOrigin = 'top left';
                    winLine.style.transform = `rotate(${Math.atan(boardRect.height / boardRect.width)}rad)`;
                    winLine.style.top = '20px';
                    winLine.style.left = '20px';
                } else {
                    // Diagonal top-right to bottom-left
                    winLine.style.width = Math.sqrt(Math.pow(boardRect.width, 2) + Math.pow(boardRect.height, 2)) + 'px';
                    winLine.style.height = '8px';
                    winLine.style.transformOrigin = 'top right';
                    winLine.style.transform = `rotate(${-Math.atan(boardRect.height / boardRect.width)}rad)`;
                    winLine.style.top = '20px';
                    winLine.style.right = '20px';
                }
                
                winLine.style.display = 'block';
            }

            // Show result modal
            function showResultModal() {
                resultModal.classList.remove('hidden');
                const modalContent = resultModal.querySelector('.relative');
                setTimeout(() => {
                    modalContent.classList.remove('opacity-0');
                    modalContent.classList.remove('scale-95');
                    modalContent.classList.add('opacity-100');
                    modalContent.classList.add('scale-100');
                }, 100);
            }

            // Hide result modal
            function hideResultModal() {
                const modalContent = resultModal.querySelector('.relative');
                modalContent.classList.add('opacity-0');
                modalContent.classList.add('scale-95');
                
                setTimeout(() => {
                    resultModal.classList.add('hidden');
                    modalContent.classList.remove('opacity-100');
                    modalContent.classList.remove('scale-100');
                }, 300);
            }

            // Reset game
            function resetGame() {
                gameState.board = Array(9).fill('');
                gameState.gameActive = true;
                gameState.winCombo = null;
                gameState.currentPlayer = 'X';
                
                hideResultModal();
                initBoard();
                updateTurnIndicator();
            }

            // Event listeners
            restartBtn.addEventListener('click', resetGame);
            playAgainBtn.addEventListener('click', resetGame);

            // Initialize the game
            initBoard();
            updateTurnIndicator();
        });
    </script>
</body>
</html>